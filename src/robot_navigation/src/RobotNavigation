#!/usr/bin/env python2
# coding=utf-8
# We must add this line , otherwise python will raise error in runtime(default encoding is ASCII)
from actionlib.action_client import _find_status_by_goal_id
import rospy
import motion_stable_control.msg
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Point,Twist, PoseStamped ,Quaternion
from tf.transformations import quaternion_from_euler,euler_from_quaternion
import actionlib
from math import e, pi,cos,sin,sqrt,exp,atan,acos
import threading
import numpy as np
# from fysom import Fysom



class Go2GoalAction(object):
    # create messages that are used to publish feedback/result
    g2g_feedback = motion_stable_control.msg.Go2GoalFeedback()
    g2g_result = motion_stable_control.msg.Go2GoalResult()
    isGo2Goal = False
    GoalOfRobot = Point(0,0,0)
    g2g_cv = threading.Condition()
    ao_twist_cv = threading.Condition()


    def __init__(self, name):
        rospy.loginfo("Init RobotNavigationServer")
        self.dis_sub = rospy.Subscriber('scan', LaserScan, self.getDistanceCallback)
        self.avoid_obstacle_twist = Twist()
        self.avoid_obstacle_twist.linear.x = 0.0
        self.avoid_obstacle_twist.linear.y = 0.0
        self.avoid_obstacle_twist.linear.z = 0.0
        self.avoid_obstacle_twist.angular.x = 0.0
        self.avoid_obstacle_twist.angular.y = 0.0
        self.avoid_obstacle_twist.angular.z = 0.0
        self.obstacle_distance = float("inf")
        self.obstacle_degree = 0.0
        self.direction = 0.0

        # self.go2goal_twist = Twist()
        # self.go2goal_twist.linear.x = 0.0
        # self.go2goal_twist.linear.y = 0.0
        # self.go2goal_twist.linear.z = 0.0
        # self.go2goal_twist.angular.x = 0.0
        # self.go2goal_twist.angular.y = 0.0
        # self.go2goal_twist.angular.z = 0.0

        self.ObstacleInRobot2Goal = False
        self.LaserScanMsg = LaserScan()

        # self.pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)

        self.odo_sub = rospy.Subscriber('odom',Odometry,self.getPoseCallback)
        self.new_twist = rospy.Publisher('cmd_vel', Twist, queue_size=10)
        self.ao_direction = rospy.Publisher('avoid_obstacle_direction', PoseStamped, queue_size=10)
        self.fw_direction = rospy.Publisher('follow_wall_direction', PoseStamped, queue_size=10)
        self.g2g_direction = rospy.Publisher('go_to_goal_direction', PoseStamped, queue_size=10)
        # self.fw_cc_direction = rospy.Publisher('follow_wall_counter_clockwise_direction', PoseStamped, queue_size=10)
        self.ao_direction = rospy.Publisher('avoid_obstacle_direction', PoseStamped, queue_size=10)
        self._action_name = name
        self._as = actionlib.SimpleActionServer(self._action_name, motion_stable_control.msg.Go2GoalAction, execute_cb=self.execute_cb, auto_start = False)
        self._as.start()
        rospy.loginfo("Robot Navigation Server Start Success")

        # # Init FSM
        # self.fsm = Fysom({
        #         'initial': 'Go2GoalState',
        #         'events': [
        #             {'name': 'TurnGo2Goal'              , 'src' : 'Go2GoalState'                    , 'dst': 'Go2GoalState'},
        #             {'name': 'TurnClockwise'            , 'src' : 'Go2GoalState'                    , 'dst': 'FollowWallClockwiseState'},
        #             {'name': 'TurnCounterClockwise'     , 'src' : 'Go2GoalState'                    , 'dst': 'FollowWallCounterClockwiseState'},
        #             {'name': 'TurnAvoidObstacle'        , 'src' : 'Go2GoalState'                    , 'dst': 'AvoidObstacleState'},
        #             {'name': 'TurnGo2Goal'              , 'src' : 'FollowWallClockwiseState'        , 'dst': 'Go2GoalState'},
        #             {'name': 'InDangerDistance'         , 'src' : 'FollowWallClockwiseState'        , 'dst': 'AvoidObstacleState'},
        #             {'name': 'TurnClockwise'            , 'src' : 'AvoidObstacleState'              , 'dst': 'FollowWallClockwiseState'},
        #             {'name': 'TurnCounterClockwise'     , 'src' : 'AvoidObstacleState'              , 'dst': 'FollowWallCounterClockwiseState'},
        #             {'name': 'TurnGo2Goal'              , 'src' : 'FollowWallCounterClockwiseState' , 'dst': 'Go2GoalState'},
        #             {'name': 'TurnAvoidObstacle'        , 'src' : 'FollowWallCounterClockwiseState' , 'dst': 'AvoidObstacleState'},

        #             {'name': 'ResetState'               , 'src' : 'FollowWallCounterClockwiseState' , 'dst': 'Go2GoalState'},
        #             {'name': 'ResetState'               , 'src' : 'FollowWallClockwiseState'        , 'dst': 'Go2GoalState'},
        #             {'name': 'ResetState'               , 'src' : 'AvoidObstacleState'              , 'dst': 'Go2GoalState'},
        #             {'name': 'ResetState'               , 'src' : 'Go2GoalState'                    , 'dst': 'Go2GoalState'}
        #         ]})
        self.state = "GO2GOALSTATE"

        self.follow_wall_choosen = 'NONE'
        self.last_distance_to_goal = 0.0

    def execute_cb(self, goal):
        self.isGo2Goal = True
        self.GoalOfRobot.x = goal.Goal.x
        self.GoalOfRobot.y = goal.Goal.y
        self.GoalOfRobot.z = goal.Goal.z

        rospy.loginfo("Get goal ( %lf , %lf , %lf )"%(goal.Goal.x , goal.Goal.y , goal.Goal.z))

        while(self.isGo2Goal == True):
            try:
                self.g2g_cv.acquire()
                self.g2g_cv.wait()
            finally:
                self.g2g_cv.release()

        # rospy.loginfo("Go to Goal Finished")

    def EuclideanDistance( self, p1 ,p2):
        dx = p1.x - p2.x
        dy = p1.y - p2.y
        dz = p1.z - p2.z
        return sqrt( dx*dx + dy*dy + dz*dz )

    def NormalizeSpeed(self , u):
        # 限制linear 和 anglar 的大小
        w = [0,0]
        if(u[0] > BURGER_MAX_LIN_VEL):# Linear
            # w[1] = u[1]*float(BURGER_MAX_LIN_VEL)/u[0]
            w[1] = u[1]
            w[0] = float(BURGER_MAX_LIN_VEL)
            # print(u)
        elif(u[0] < -BURGER_MAX_LIN_VEL):
            # w[1] = u[1]*float(-BURGER_MAX_LIN_VEL)/u[0]
            w[1] = u[1]
            w[0] = float(-BURGER_MAX_LIN_VEL)

        # rospy.loginfo("Update LIN_VEL U : ( %lf , %lf ), W : ( %lf , %lf )"%(u[0],u[1],w[0],w[1]))


        if(w[1] > BURGER_MAX_ANG_VEL):# Angular
            w[0] = w[0]*float(BURGER_MAX_ANG_VEL)/w[1]
            w[1] = float(BURGER_MAX_ANG_VEL)
        elif(u[1] < -BURGER_MAX_ANG_VEL):# Angular
            w[0] = w[0]*float(-BURGER_MAX_ANG_VEL)/w[1]
            w[1] = float(-BURGER_MAX_ANG_VEL)

        # #Some Constant
        # BURGER_MAX_LIN_VEL  = 0.22/2
        # BURGER_MAX_ANG_VEL  = 2.84/2
        # rospy.loginfo("Update ANG_VEL U : ( %lf , %lf ), W : ( %lf , %lf )"%(u[0],u[1],w[0],w[1]))

        return w

    def getDistanceCallback(self,msg): # Callback of Lidar

        self.LaserScanMsg = msg

        # print ( "First Value %f , Last Value %f" )%( msg.ranges[0], msg.ranges[359] )
        self.ao_twist_cv.acquire()

        # self.obstacle_distance = self.getNthSmallNumberOfList(msg.ranges,1) # min
        self.obstacle_distance = min(msg.ranges) # min
        # rospy.loginfo("Min Distance : %lf, Index %d",self.obstacle_distance, msg.ranges.index( self.obstacle_distance ) )
        # self.obstacle_distance = self.getNthSmallNumberOfList(list(msg.ranges),2) # second
        # self.obstacle_degree = ( self.direction + msg.angle_min + msg.ranges.index( self.obstacle_distance )*msg.angle_increment )
        self.obstacle_degree = ( msg.angle_min + msg.ranges.index( self.obstacle_distance )*msg.angle_increment )
        
        # self.obstacle_distance = msg.ranges[0]
        # self.obstacle_degree = self.direction



        # print "direction : %lf , obstacle_degree : %lf"%(self.direction,obstacle_degree)
        # print "Direction : %lf"%(self.direction)
        # print "AngleMin : %lf"%( msg.angle_min )
        # print "Increment : %lf"%msg.angle_increment
        # print "Degree : %lf"%( msg.angle_min + msg.ranges.index( self.obstacle_distance )*msg.angle_increment )
        # print "Obstacle Direction : %lf"%( self.obstacle_degree )
        # print "Avoid Obstacle Direction : %lf"%( self.obstacle_degree + pi )

        # if( msg.range_min < self.obstacle_distance < msg.range_max ):
        if( msg.range_min < self.obstacle_distance < msg.range_max ):
            # Avoid Obstacle
            # c = 0.003718
            # c = 0.05
            c = 1
            # c = 0.03168# = =! 
            e = 0
            k = (1/self.obstacle_distance)*(c/(self.obstacle_distance ** 2 + e))

            
            u = [ k * self.obstacle_distance * cos(self.obstacle_degree + pi ) , k * self.obstacle_distance * sin(self.obstacle_degree + pi) ] # k
            # u = [ k * self.obstacle_distance * cos(self.obstacle_degree) , k * self.obstacle_distance * sin(self.obstacle_degree) ] # k
            
            # u = self.NormalizeSpeed(u)
            
            

            rospy.loginfo(("ObstacleDistance : %lf")%self.obstacle_distance)
            # print(k)
            rospy.loginfo(("ObstacleDegree : %lf")%( self.obstacle_degree + pi ))
            # print('u : %lf , %lf'%( u[0], u[1] ) )  

            self.avoid_obstacle_twist.linear.x = u[0]
            self.avoid_obstacle_twist.linear.y = 0.0
            self.avoid_obstacle_twist.linear.z = 0.0

            self.avoid_obstacle_twist.angular.x = 0.0
            self.avoid_obstacle_twist.angular.y = 0.0
            self.avoid_obstacle_twist.angular.z = u[1]

            # print "Value of K : %lf , Value of FrontDistance : %lf"%( k , self.obstacle_distance )
            # print "AO_TWIST %lf , %lf"%(self.avoid_obstacle_twist.linear.x,self.avoid_obstacle_twist.angular.z)



        else:
            self.ObstacleInRobot2Goal = False
            self.obstacle_distance = float("inf")
            self.avoid_obstacle_twist.linear.x = 0.0
            self.avoid_obstacle_twist.linear.y = 0.0
            self.avoid_obstacle_twist.linear.z = 0.0
            self.avoid_obstacle_twist.angular.x = 0.0
            self.avoid_obstacle_twist.angular.y = 0.0
            self.avoid_obstacle_twist.angular.z = 0.0


        self.ao_twist_cv.notify()
        self.ao_twist_cv.release()

    def getNthSmallNumberOfList(self,list,index):# index is start from 1 
        list.sort()
        return list[index-1]
    def getGo2GoalTwist(self,msg):

        # rospy.loginfo((" New Position : %lf , %lf")%( msg.pose.pose.position.x , msg.pose.pose.position.y))
        robot_post                      = np.array([
            [msg.pose.pose.position.x],
            [msg.pose.pose.position.y]
        ])

        robot_dest                      = np.array([
            [self.GoalOfRobot.x],
            [self.GoalOfRobot.y]
        ])

        # // ROS_INFO("TEST3")

        epsilon = 0.1
        
        va               = np.array([
            [1,0],
            [0,1/epsilon]
        ])

        
        # rospy.loginfo("EulerYaw %lf "%yaw)

        # // tf2::Quaternion quat_tf;
        # // tf2::fromMsg(msg->pose.pose.orientation, quat_tf);
        
        # // tf2Scalar angle = quat_tf.getAngle();

        # // Matrix<double> theta            = { { cos(msg->pose.pose.orientation.z) , sin(msg->pose.pose.orientation.z) },
        # //                                     { -sin(msg->pose.pose.orientation.z) , cos(msg->pose.pose.orientation.z) }
        # // };
        # // Matrix<double> theta            = { { cos(-yaw) , sin(-yaw) },
        # //                                     { -sin(-yaw) , cos(-yaw) }
        # // };
        yaw = self.direction
        theta            = np.array([
            [cos(yaw) , sin(yaw)],
            [-sin(yaw) , cos(yaw)]
        ])
        
        e_g2g                       = robot_dest - robot_post
        # // e_g2g                       = robot_post - robot_dest;
        # // ROS_INFO("TEST5b"); 
        # print e_g2g
        e_g2g                       = e_g2g + 0.001
        # print e_g2g
        # print '===================='
        # // ROS_INFO("TEST5c"); 
        
        # // e_g2g.PrintMatrix();

        alpha = 10.0
        # // double k = BURGER_MAX_LIN_VEL*( 1 - (exp( -alpha*e_g2g.normf()*e_g2g.normf() ) ) / (e_g2g.normf()) );
        e_g2g_normf = np.linalg.norm(e_g2g)
        # print "e_g2g_normf : %lf"%e_g2g_normf
        k = BURGER_MAX_LIN_VEL*( (1 - exp( -alpha*e_g2g_normf*e_g2g_normf ))  / ( e_g2g_normf ) )

        # // ROS_INFO("TEST6"); 
        # print "K : %lf"%k
        # print "Yaw : %lf"%yaw
        u_g2g                       = e_g2g * k
        # print theta
        # print "VA:"
        # print va
        # print "theta:"
        # print theta
        # print "u_g2g:"
        # print u_g2g
        # print '===================='

        # // u_g2g.PrintMatrix();
        rlt                         = va.dot(theta).dot(u_g2g); 
        # print rlt
        # print '===================='

        # rospy.loginfo("rlt value")
        # print rlt
        go2goal_twist = Twist()
        go2goal_twist.linear.x = rlt[0][0]
        go2goal_twist.linear.y = 0.0
        go2goal_twist.linear.z = 0.0

        go2goal_twist.angular.x = 0.0
        go2goal_twist.angular.y = 0.0
        go2goal_twist.angular.z = rlt[1][0]

        # 計算機器人和Goal之間是否有障礙物
        # max_laser_value = -float("inf") # 機器人的方向和Goal方向的內積值最大時的距離 
        # max_inner_product = -float("inf")
        # for i in range(360):
        #     [x_r,y_r] = [ cos(self.LaserScanMsg.angle_min + i*self.LaserScanMsg.angle_increment) , sin(self.LaserScanMsg.angle_min + i*self.LaserScanMsg.angle_increment) ]
        #     [x_g,y_g] = e_g2g
        #     ip = x_r * x_g + y_r * y_g
        #     if(ip > max_inner_product):
        #         max_inner_product = ip
        #         max_laser_value = self.LaserScanMsg.ranges[i]

        # # rospy.loginfo("MAX_LASER_VALUE : %lf"%max_laser_value)
        # if( self.LaserScanMsg.range_min < max_laser_value < WarningDistance):
        #     self.ObstacleInRobot2Goal  = True
        # else:
        #     self.ObstacleInRobot2Goal = False


        return go2goal_twist
        # print "Test Go2Goal Twist"
        # print self.go2goal_twist
        # self.new_twist.publish(twist);
        #// ROS_INFO("Update Twist");
    # def TurnClockwise(self):

    # def TurnCounterClockwise(self):

    # def InDangerDistance(self):

    # def InSafeDistance(self):

    def getTwistfromVectorFW(self,v):
        twist = [0,0]
        x = v[0]
        y = v[1]
        r = sqrt(x ** 2 + y ** 2)
        theta = 0
        if(r != 0):
            theta = acos(x/r)
        if(v[0] >= 0 and v[1] >= 0): # 第一象限
            twist = [r,pi/2 - theta]
        elif(v[0] < 0 and v[1] >= 0): # 第二象限
            twist = [r,theta - pi/2]
        elif(v[0] >= 0 and v[1] < 0): # 第四象限
            twist = [r,-(pi/2 + theta)]
        elif(v[0] < 0 and v[1] < 0): # 第三象限
            twist = [r,pi*3/2 - theta]
        else:
            twist = [0,0]

        return twist
    def getTwistfromVectorAO(self,v):
        twist = [0,0]
        x = v[0]
        y = v[1]
        r = sqrt(x ** 2 + y ** 2)
        rospy.loginfo("VectorAO : ( %lf , %lf ) ",v[0],v[1])
        theta = 0
        if(r != 0):
            theta = acos(x/r)
        if(v[0] >= 0 and v[1] >= 0): # 第一象限
            twist = [r,pi/2 - theta]
        elif(v[0] < 0 and v[1] >= 0): # 第二象限
            twist = [r,theta - pi/2]
        elif(v[0] >= 0 and v[1] < 0): # 第四象限
            twist = [-r,pi/2 - theta]
        elif(v[0] < 0 and v[1] < 0): # 第三象限
            twist = [-r,-(theta - pi/2)]
        else:
            twist = [0,0]

        rospy.loginfo("TwistAO : ( %lf , %lf ) ",twist[0],twist[1])
        return twist


    # def ObstacleInRobot2Goal(self):
    #     [x,y] = [ self.obstacle_distance* cos(self.obstacle_degree) , self.obstacle_distance* sin(self.obstacle_degree) ]
    #     if(x >= -(DangerDistance + DistanceError) and x <= (DangerDistance + DistanceError) ):
    #         if(self.obstacle_distance <= WarningDistance ):
    #             return True
    #     return False


    def getPoseCallback(self,msg):

        # Get Euler Angle from Quaternion
        (r, p, yaw) = euler_from_quaternion([msg.pose.pose.orientation.x, msg.pose.pose.orientation.y, msg.pose.pose.orientation.z, msg.pose.pose.orientation.w])
        self.direction = yaw

        
        goal_distance = self.EuclideanDistance(self.GoalOfRobot , msg.pose.pose.position)

        if(self.isGo2Goal):
            self.g2g_feedback.Position = msg.pose.pose.position
            self._as.publish_feedback(self.g2g_feedback)

        # // ROS_INFO("Position %lf %lf",msg->pose.pose.position.x,msg->pose.pose.position.y);
        # // ROS_INFO("DistanceError %lf " , EuclideanDistance(GoalOfRobot , msg->pose.pose.position) );

            if(goal_distance <= DistanceError): # // Arrive goal
                # rospy.loginfo("Go2Goal Success")
                go2goal_twist = Twist()
                go2goal_twist.linear.x = 0.0
                go2goal_twist.linear.y = 0.0
                go2goal_twist.linear.z = 0.0

                go2goal_twist.angular.x = 0.0
                go2goal_twist.angular.y = 0.0
                go2goal_twist.angular.z = 0.0
                self._as.set_succeeded(self.g2g_result)

                self.g2g_cv.acquire()
                self.isGo2Goal = False
                self.g2g_cv.notify()
                self.g2g_cv.release()

                self.new_twist.publish(go2goal_twist)


            elif (self._as.is_preempt_requested() ):
                # // Notify action cancellation
                # rospy.loginfo("py_go_to_goal_control : Preempted")
                # // Action cancellation and consider action as failure and save to variable
                self._as.set_preempted()
                self.g2g_cv.acquire()
                self.isGo2Goal = False
                self.g2g_cv.notify()
                self.g2g_cv.release()
                go2goal_twist = Twist()
                go2goal_twist.linear.x = 0.0
                go2goal_twist.linear.y = 0.0
                go2goal_twist.linear.z = 0.0

                go2goal_twist.angular.x = 0.0
                go2goal_twist.angular.y = 0.0
                go2goal_twist.angular.z = 0.0
                self.new_twist.publish(go2goal_twist)

                # Reset State
                self.state = 'GO2GOALSTATE'
                self.follow_wall_choosen = 'NONE'
                # self.fsm.ResetState()

            else :
                # Avoid Obstacle Direction
                # Avoid Obstacle
                u_ao = np.array([ [ self.avoid_obstacle_twist.linear.x ] 
                                , [ self.avoid_obstacle_twist.angular.z ] ])

                
                ps = PoseStamped()
                ps.header.frame_id = 'odom'
                ps.header.stamp = rospy.Time.now()
                ps.pose.position = msg.pose.pose.position
                # (x,y,z,w) = quaternion_from_euler(0, 0, self.obstacle_degree + pi)
                (x,y,z,w) = quaternion_from_euler(0, 0, self.obstacle_degree + self.direction + pi)
                # (x,y,z,w) = quaternion_from_euler(0, 0, atan( u_ao[1][0]/u_ao[0][0] ) )#=========================
                # print("ObstacleDegree+Pi = %lf , atan = %lf"%( (self.obstacle_degree + pi)%(2*pi), (atan( u_ao[1][0]/u_ao[0][0] ) + 2*pi)%(2*pi)  ))
                
                # print(("x : %lf, y : %lf")%(u_ao[0][0] , u_ao[1][0] ))
                ps.pose.orientation = Quaternion(x,y,z,w)
                self.ao_direction.publish(ps)



                # Follow Wall Direction
                fw = PoseStamped()
                fw.header.frame_id = 'odom'
                fw.header.stamp = rospy.Time.now()
                fw.pose.position = msg.pose.pose.position

                go2goal_twist = self.getGo2GoalTwist(msg)

                # Go2Goal
                robot_post                      = np.array([
                    [msg.pose.pose.position.x],
                    [msg.pose.pose.position.y]
                ])

                robot_dest                      = np.array([
                    [self.GoalOfRobot.x],
                    [self.GoalOfRobot.y]
                ])
                u_g2g = robot_dest - robot_post

                # Go2Goal Direction
                gg = PoseStamped()
                gg.header.frame_id = 'odom'
                gg.header.stamp = rospy.Time.now()
                gg.pose.position = msg.pose.pose.position
                goal_vector = np.transpose(u_g2g)
                unit_goal_vector = goal_vector/np.linalg.norm(goal_vector)
                radian_between_x_coord_and_goal = np.arccos(unit_goal_vector[0][0])
                (x,y,z,w) = quaternion_from_euler(0, 0, radian_between_x_coord_and_goal )
                gg.pose.orientation = Quaternion(x,y,z,w)
                self.g2g_direction.publish(gg)
                
                ################################################################
                # self.fw_direction.publish(fw)

                

                # Follow Wall
                alpha = 1
                # Clockwise
                u_fw_c = alpha * np.array([ [0,1],[-1,0] ]).dot(u_ao)
                # CounterClockwise
                u_fw_cc = alpha * np.array([ [0,-1],[1,0] ]).dot(u_ao)

                # inner product of Follow Wall and Go2Goal
                #inner product of Clockwise
                # ip_c = u_g2g[0][0]* u_fw_c[0][0] + u_g2g[1][0]* u_fw_c[1][0] # np.transpose(u_g2g).dot(u_fw_c)
                # ip_cc = u_g2g[0][0]* u_fw_cc[0][0] + u_g2g[1][0]* u_fw_cc[1][0] # np.transpose(u_g2g).dot(u_fw_cc)
                ip_c = np.transpose(u_g2g).dot(u_fw_c)
                ip_cc = np.transpose(u_g2g).dot(u_fw_cc)

                # print("ip_c : %lf , ip_cc : %lf"%(ip_c,ip_cc))

                aot = self.avoid_obstacle_twist
                ggt = go2goal_twist
                twist = Twist()
                twist.linear.x = 0.0
                twist.linear.y = 0.0
                twist.linear.z = 0.0
                twist.angular.x = 0.0
                twist.angular.y = 0.0
                twist.angular.z = 0.0
                

                # print "TWIST %lf , %lf"%(twist.linear.x,twist.angular.z)
                # print "ip_c %lf , ip_cc %lf"%(ip_c,ip_cc)
                # Check if Obstacle is in area between Robot and Goal
                msgLS = self.LaserScanMsg
                # goal_vector = np.transpose(u_g2g)
                # unit_goal_vector = goal_vector/np.linalg.norm(goal_vector)
                # radian_between_x_coord_and_goal = np.arccos(unit_goal_vector[0][0])
                # print("Unit Goal Vector : ")
                # print(unit_goal_vector)
                if(unit_goal_vector[0][0] < 0):
                    radian_between_x_coord_and_goal = 2*pi - radian_between_x_coord_and_goal
                theta_goal = -(pi/2 - radian_between_x_coord_and_goal)
                for i in range(360):
                    theta_tmp = msgLS.angle_min + i*msgLS.angle_increment + theta_goal
                    [x,y] = [ msgLS.ranges[i]* cos( theta_tmp ) , msgLS.ranges[i]* sin( theta_tmp ) ]
                    if( msgLS.range_min < msgLS.ranges[i] < msgLS.range_max ):
                        if( -( DangerDistance )<= x <= ( DangerDistance ) ):
                            # if(msgLS.ranges[i] <= WarningDistance ):
                            if(msgLS.ranges[i] <= msgLS.range_max ):
                                self.ObstacleInRobot2Goal = True
                                break
                    self.ObstacleInRobot2Goal = False
                rospy.loginfo("self.ObstacleInRobot2Goal : %s"%( self.ObstacleInRobot2Goal ) )

                # Next State   
                # if distance between turtlbot3 and goal is smaller than obstacle , Go2Goal first  
                # 每秒更新機器人的位置30次
                # 因為每次更新機器人的位置中間機器人會移動，所以只要機器人往Goal前進，distance(goal,location) < last_distance一定會成立
                # 故follow_wall_choosen == None不會成立
                # 也就是機器人會一直維持在Go2GoalState  
                # WHY : AvoidObstacle state時機器人不會後退？
                # WHY : 機器人會往牆壁轉？ ANS : 可能是因為ROS的角度正向是`逆`時鐘方向, BUT 好像角度本來就是逆時鐘

                if(self.obstacle_distance <= ( WarningDistance + DangerDistance )/2):
                # if(self.obstacle_distance <= WarningDistance ):
                    if(self.obstacle_distance <= DangerDistance):
                        if(self.state != 'AVOID_OBSTACLE_STATE' ):
                            print("From state %s to AVOID_OBSTACLE_STATE"%self.state)
                        self.state = 'AVOID_OBSTACLE_STATE'
                        self.follow_wall_choosen = 'NONE'

                    # TODO: When in FOLLOW_WALL state , what conditions to go back to Go2GoalState ?
                    #       1. There is no obstacle between Goal and Turtlebot3
                    #       2. 
                    # elif(self.EuclideanDistance(self.GoalOfRobot , msg.pose.pose.position) < self.last_distance_to_goal):
                    #     # self.fsm.TurnGo2Goal()
                    #     self.state = 'GO2GOALSTATE'
                    #     # self.follow_wall_choosen = 'NONE'
                    #     print("Turn Go2Goal")
                    # DangerDistance < obstacle_distance <= WarningDistance
                    # elif( not self.ObstacleInRobot2Goal ):
                    elif( not self.ObstacleInRobot2Goal ):
                        if(self.state != 'GO2GOALSTATE' ):
                            rospy.loginfo("From state %s to GO2GOALSTATE"%self.state)
                        self.state = 'GO2GOALSTATE'
                    elif(self.follow_wall_choosen == 'NONE'):
                        if(ip_c > 0.0):
                            if(self.state != 'FOLLOW_CLOCKWISE'):
                                rospy.loginfo("From state %s to FOLLOW_CLOCKWISE"%self.state)

                            self.last_distance_to_goal = self.EuclideanDistance(self.GoalOfRobot , msg.pose.pose.position)
                            self.follow_wall_choosen = "CLOCKWISE"
                            # self.fsm.TurnClockwise()
                            self.state = "FOLLOW_CLOCKWISE"

                        elif(ip_cc > 0.0):
                            if(self.state != 'FOLLOW_COUNTER_CLOCKWISE'):
                                rospy.loginfo("From state %s to FOLLOW_COUNTER_CLOCKWISE"%self.state)

                            self.last_distance_to_goal = self.EuclideanDistance(self.GoalOfRobot , msg.pose.pose.position)
                            self.follow_wall_choosen = "COUNTER_CLOCKWISE"
                            # self.fsm.TurnCounterClockwise()
                            self.state = 'FOLLOW_COUNTER_CLOCKWISE'
                    else:
                        if(self.follow_wall_choosen == "CLOCKWISE"):
                            if(self.state != 'FOLLOW_CLOCKWISE'):
                                rospy.loginfo("From state %s to FOLLOW_CLOCKWISE"%self.state)

                            # self.fsm.TurnClockwise()
                            self.state = 'FOLLOW_CLOCKWISE'
                        else:
                            if(self.state != 'FOLLOW_COUNTER_CLOCKWISE'):
                                rospy.loginfo("From state %s to FOLLOW_COUNTER_CLOCKWISE"%self.state)

                            # self.fsm.TurnCounterClockwise()
                            self.state = 'FOLLOW_COUNTER_CLOCKWISE'
                else:
                    if(self.state != 'GO2GOALSTATE'):
                        rospy.loginfo("From state %s to GO2GOALSTATE"%self.state)
                    self.state = 'GO2GOALSTATE'


                # if( self.fsm.isstate( 'Go2GoalState' )):
                if( self.state == 'GO2GOALSTATE' ):
                    # print "Current State : Go2GoalState"
                    twist = go2goal_twist
                    # twist.linear.x  = ggt.linear.x
                    # twist.angular.z = ggt.angular.z
                    # rospy.loginfo("At GO2GOALSTATE : ( %lf , %lf )"%( twist.linear.x, twist.angular.z  ))

                # elif( self.fsm.isstate( 'FollowWallClockwiseState' ) ):
                elif( self.state == 'FOLLOW_CLOCKWISE' ):
                    # print "Current State : FollowWallClockwiseState"
                    w = self.NormalizeSpeed( self.getTwistfromVectorFW([u_fw_c[0][0] , u_fw_c[1][0]]) )
                    # w = ( self.getTwistfromVectorFW([u_fw_c[0][0] , u_fw_c[1][0]]) )
                    # twist.linear.x  = w[0] * u_ao[0]/abs(u_ao[0]) # 如果原本的linear是負數，FOLLOW_WALL的linear就要乘-1
                    # twist.angular.z = w[1] * u_ao[1]/abs(u_ao[1]) # 如果原本的Angular是負數，FOLLOW_WALL的Angular就要乘-1
                    twist.linear.x  = w[0]
                    twist.angular.z = w[1]
                    # print "u_fw_c : "
                    # print u_fw_c
                    # print "tan of direction : %lf"%(u_fw_c[1][0] / u_fw_c[0][0])
                    if(u_fw_c[0][0] == 0 and u_fw_c[1][0] > 0 ):
                        (x,y,z,w) = quaternion_from_euler(0, 0, pi/2 )
                    elif(u_fw_c[0][0] == 0 and u_fw_c[1][0] < 0 ):
                        (x,y,z,w) = quaternion_from_euler(0, 0, -pi/2 )
                    else:
                        # (x,y,z,w) = quaternion_from_euler(0, 0, self.obstacle_degree + pi*3/2 )
                        (x,y,z,w) = quaternion_from_euler(0, 0, self.obstacle_degree + pi/2)
                    fw.pose.orientation = Quaternion(x,y,z,w)
                    rospy.loginfo("FOLLOW_CLOCKWISE Direction ( %lf , %lf )"%( u_fw_c[0][0] , u_fw_c[1][0] ) )
                    rospy.loginfo("At FOLLOW_CLOCKWISE : ( %lf , %lf )"%( twist.linear.x, twist.angular.z  ))

                # elif( self.fsm.isstate( 'AvoidObstacleState' ) ):
                elif( self.state == 'AVOID_OBSTACLE_STATE' ):
                    # print("Current State : AvoidObstacleState")
                    w = self.NormalizeSpeed( self.getTwistfromVectorAO([ aot.linear.x , aot.angular.z ]) )
                    # w = ( self.getTwistfromVectorAO([ aot.linear.x , aot.angular.z ]) )
                    twist.linear.x  = w[0]
                    twist.angular.z = w[1]
                    rospy.loginfo("AVOID_OBSTACLE_STATE Direction ( %lf , %lf )"%( aot.linear.x , aot.angular.z ) )
                    rospy.loginfo("At AVOID_OBSTACLE_STATE : ( %lf , %lf )"%( twist.linear.x, twist.angular.z  ))
                # elif( self.fsm.isstate( 'FollowWallCounterClockwiseState' ) ):
                elif( self.state == 'FOLLOW_COUNTER_CLOCKWISE' ):
                    # print "Current State : FollowWallCounterClockwiseState"
                    w = self.NormalizeSpeed( self.getTwistfromVectorFW([u_fw_cc[0][0] , u_fw_cc[1][0]]) )
                    # w = ( self.getTwistfromVectorFW([u_fw_cc[0][0] , u_fw_cc[1][0]]) )
                    twist.linear.x  = w[0]
                    twist.angular.z = w[1]
                    # print "u_fw_cc : "
                    # print u_fw_cc
                    # print "tan of direction : %lf"%(u_fw_cc[1][0] / u_fw_cc[0][0])
                    if(u_fw_cc[0][0] == 0 and u_fw_cc[1][0] > 0 ):
                        (x,y,z,w) = quaternion_from_euler(0, 0, pi/2 )
                    elif(u_fw_cc[0][0] == 0 and u_fw_cc[1][0] < 0 ):
                        (x,y,z,w) = quaternion_from_euler(0, 0, -pi/2 )
                    else:
                        (x,y,z,w) = quaternion_from_euler(0, 0, self.obstacle_degree + pi*3/2)
                        # (x,y,z,w) = quaternion_from_euler(0, 0, self.obstacle_degree + pi/2 )
                    fw.pose.orientation = Quaternion(x,y,z,w)
                    rospy.loginfo("FOLLOW_COUNTER_CLOCKWISE Direction ( %lf , %lf )"%( u_fw_cc[0][0] , u_fw_cc[1][0] ) )
                    rospy.loginfo("At FOLLOW_COUNTER_CLOCKWISE : ( %lf , %lf )"%( twist.linear.x, twist.angular.z  ))

                # Follow Wall Direction
                self.fw_direction.publish(fw)
                # TODO : Remove comment to control robot automactivily
                # print(twist)
                # rospy.loginfo('twist : %lf , %lf'%( twist.linear.x, twist.angular.z ) )  

                self.new_twist.publish(twist)
                

#Some Constant
BURGER_MAX_LIN_VEL  = 0.22/2
BURGER_MAX_ANG_VEL  = 2.84/2
DistanceError       = 0.1
WarningDistance = 0.4
DangerDistance = 0.2


if __name__ == '__main__':
    rospy.init_node('robot_navigation')
    server = Go2GoalAction('Go2GoalAction')
    # print "Test"
    rospy.spin()
    # try:
    #     rospy.init_node('robot_navigation')
    #     server = Go2GoalAction('Go2GoalAction')
    #     print "Test"
    #     rospy.spin()
    # except:
    #     print "Error"

    #     rospy.signal_shutdown("Error occurred")
